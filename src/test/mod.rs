#![cfg(test)]

use crate::{
    algebra::{AddByRef, MapBuilder, ZSetHashMap},
    circuit::{operator_traits::SourceOperator, Root, Stream},
    finite_map,
    operator::Generator,
};
use ordered_float::OrderedFloat;
use std::{cell::RefCell, ops::Deref, rc::Rc};

type Weight = isize;

fn make_generator() -> impl SourceOperator<ZSetHashMap<i64, i64>> {
    let mut z = ZSetHashMap::new();
    let mut count = 0i64;

    Generator::new(move || {
        count += 1;
        let result = z.clone();
        z.increment(&count, 1i64);
        result
    })
}

// Apply functions to a stream
#[test]
fn map() {
    let actual_data = Rc::new(RefCell::new(Vec::new()));
    let actual_data_clone = actual_data.clone();
    let root = Root::build(|circuit| {
        circuit
            .add_source(make_generator())
            .apply(|map| map.add_by_ref(map))
            .inspect(move |map| actual_data.borrow_mut().push(map.clone()));
    })
    .unwrap();

    for _ in 0..3 {
        root.step().unwrap()
    }

    let expected = vec![
        finite_map! {},
        finite_map! { 1 => 2 },
        finite_map! { 1 => 2, 2 => 2 },
    ];
    assert_eq!(&expected, actual_data_clone.borrow().deref());
}

fn make_tuple_generator() -> impl SourceOperator<ZSetHashMap<(i64, i64), i64>> {
    let mut z = ZSetHashMap::new();
    let mut count = 0;

    Generator::new(move || {
        count += 1;
        let result = z.clone();
        z.increment(&(count, count + 1), 1i64);
        result
    })
}

// Test a map on a relation containing tuples
#[test]
fn tuple_relation_test() {
    let actual_data = Rc::new(RefCell::new(Vec::new()));
    let actual_data_clone = actual_data.clone();
    let root = Root::build(|circuit| {
        circuit
            .add_source(make_tuple_generator())
            .apply(|map| map.add_by_ref(map))
            .inspect(move |map| actual_data.borrow_mut().push(map.clone()));
    })
    .unwrap();

    for _ in 0..3 {
        root.step().unwrap()
    }

    let expected = vec![
        finite_map! {},
        finite_map! { (1, 2) => 2 },
        finite_map! {
            (1, 2) => 2,
            (2, 3) => 2,
        },
    ];
    assert_eq!(&expected, actual_data_clone.borrow().deref());
}

// Test a filter on a relation containing tuples
#[test]
fn tuple_filter_test() {
    let actual_data = Rc::new(RefCell::new(Vec::new()));
    let actual_data_clone = actual_data.clone();
    let root = Root::build(|circuit| {
        circuit
            .add_source(make_tuple_generator())
            .filter_keys::<_, _, ZSetHashMap<_, _>, _>(|(left, _)| left % 2 == 0)
            .inspect(move |map| actual_data.borrow_mut().push(map.clone()));
    })
    .unwrap();

    for _ in 0..3 {
        root.step().unwrap()
    }

    let expected = vec![finite_map! {}, finite_map! {}, finite_map! { (2, 3) => 1 }];
    assert_eq!(&expected, actual_data_clone.borrow().deref());
}

// The following sets of tests simulate the code generated by the SQL compiler

#[cfg(test)]
fn circuit_generator() -> impl FnMut(i64) -> i64 {
    let input = Rc::new(RefCell::new(0));
    let input_external = input.clone();
    let gen = Generator::new(move || input.borrow().clone());

    let result = Rc::new(RefCell::new(0));
    let result_external = result.clone();
    let root = Root::build(|circuit| {
        circuit
            .add_source(gen)
            .apply(|x| x + x)
            .inspect(move |m| { *result.borrow_mut() = m.clone()});
    })
    .unwrap();

    return move |i: i64| {
        *input_external.borrow_mut() = i;
        root.step().unwrap();
        return result_external.borrow().clone();
    };
}

#[test]
fn generator_tester() {
    let mut f = circuit_generator();

    let mut expected = f(0);
    assert_eq!(expected, 0);

    expected = f(1);
    assert_eq!(expected, 2);
}

#[cfg(test)]
fn zset_circuit_generator() -> impl FnMut(ZSetHashMap<i64, i64>) -> ZSetHashMap<i64, i64> {
    let input = Rc::new(RefCell::<ZSetHashMap<i64, i64>>::new(Default::default()));
    let input_external = input.clone();
    let input = Generator::new(move || input.borrow().clone());

    let result = Rc::new(RefCell::new(ZSetHashMap::new()));
    let result_external = result.clone();
    let root = Root::build(|circuit| {
        circuit
            .add_source(input)
            .apply(|x| x.add_by_ref(x))
            .inspect(move |m| { *result.borrow_mut() = m.clone()});
    })
    .unwrap();

    return move |i| {
        *input_external.borrow_mut() = i;
        root.step().unwrap();
        return result_external.borrow().clone();
    };
}

#[test]
fn zset_generator_tester() {
    let mut f = zset_circuit_generator();

    let mut expected = f(Default::default());
    assert_eq!(expected, ZSetHashMap::<i64, i64>::new());

    let mut z = ZSetHashMap::<i64, i64>::new();
    z.increment(&1, 1);
    expected = f(z);
    assert_eq!(expected, finite_map! { 1 => 2 });
}

#[cfg(test)]
#[allow(dead_code)]
fn test_scalar_generator() -> impl FnMut(i32) -> i32 {
    let i = Rc::new(RefCell::<i32>::new(Default::default()));
    let i_external = i.clone();
    let i = Generator::new(move || i.borrow().clone());
    let o = Rc::new(RefCell::<i32>::new(Default::default()));
    let o_external = o.clone();
    let root = Root::build(|circuit| {
        let i = circuit.add_source(i);
        let op = i.apply(|x| x + 1);
        op.inspect(move |m| { *o.borrow_mut() = m.clone() });
    }).unwrap();
    return move |i| {
        *i_external.borrow_mut() = i;
        root.step().unwrap();
        return o_external.borrow().clone();
    };
}

#[cfg(test)]
#[allow(dead_code)]
fn test_zset_generator() -> impl FnMut(ZSetHashMap<i32, i64>) -> ZSetHashMap<i32, i64> {
    let i = Rc::new(RefCell::<ZSetHashMap<i32, i64>>::new(Default::default()));
    let i_external = i.clone();
    let i = Generator::new(move || i.borrow().clone());
    let o = Rc::new(RefCell::<ZSetHashMap<i32, i64>>::new(Default::default()));
    let o_external = o.clone();
    let root = Root::build(|circuit| {
        let i = circuit.add_source(i);
        let op = i.apply(|x| x.add_by_ref(&x));
        op.inspect(move |m| { *o.borrow_mut() = m.clone() });
    }).unwrap();
    return move |i| {
        *i_external.borrow_mut() = i;
        root.step().unwrap();
        return o_external.borrow().clone();
    };
}

#[cfg(test)]
#[allow(dead_code)]
#[allow(non_snake_case)]
fn circuit_generator1() -> impl FnMut(ZSetHashMap<(i32, OrderedFloat<f32>, bool), Weight>) -> ZSetHashMap<(i32, OrderedFloat<f32>, bool), Weight> {
    let T = Rc::new(RefCell::<ZSetHashMap<(i32, OrderedFloat<f32>, bool), Weight>>::new(Default::default()));
    let T_external = T.clone();
    let T = Generator::new(move || T.borrow().clone());
    let V = Rc::new(RefCell::<ZSetHashMap<(i32, OrderedFloat<f32>, bool), Weight>>::new(Default::default()));
    let V_external = V.clone();
    let root = Root::build(|circuit| {
        let T = circuit.add_source(T);
        let id27: Stream<_, ZSetHashMap<(i32, OrderedFloat<f32>, bool), Weight>> = T.filter_keys(|t| t.2);
        let id34: Stream<_, ZSetHashMap<(i32, OrderedFloat<f32>, bool), Weight>> = id27.map_keys(|t| (t.0, t.1, t.2));
        let id37: Stream<_, ZSetHashMap<(i32, OrderedFloat<f32>, bool), Weight>> = id34.distinct();
        id37.inspect(move |m| { *V.borrow_mut() = m.clone() });
    }).unwrap();
    return move |T| {
        *T_external.borrow_mut() = T;
        root.step().unwrap();
        return V_external.borrow().clone();
    };
}
